---
weight: 1
title: "现代验证工具：SAT 与 SMT 求解器"
description: "现代验证工具：SAT 与 SMT 求解器"
draft: true
---

# 1. 引言

SAT 和 SMT 求解器是计算机科学中形式验证和自动推理领域的核心工具。SAT 问题关注于判断一个命题逻辑公式是否存在一个满足其为真的变量赋值，而 SMT 求解器则在 SAT 的基础上扩展，支持更复杂的逻辑理论（如算术、数组、函数等），从而能够处理更广泛的验证任务。

# 2. SAT 问题

## 2.1 定义

SAT 问题：给定一个命题逻辑公式 $ \alpha $，判断是否存在一个满足解（satisfying solution），即一组变量赋值使得 $ \alpha $ 为真。

- 示例：  
  $$\(\alpha(x_1, x_2, x_3) := (x_1 \wedge x_2 \vee x_3) \wedge (x_1 \wedge \neg x_3 \vee x_2)\)$$
  满足解：$$\(x_1 = 1, x_2 = 1, x_3 = 0\)$$

## 2.2 复杂性

由于需要检查所有可能的赋值组合，SAT问题的计算复杂性为 $2^n$ （其中 $n$ 为变量数），属于指数级。

SAT问题是第一个被证明为NP完全（NP-complete）的问题（Cook, 1971）。尽管其复杂性很高，经过30多年的工程努力，现代SAT求解器已能有效解决许多实际问题。

## 2.3 SAT 在验证中的应用

SAT问题在形式验证中有着广泛应用，尤其是在自动机的可达性分析和不变性检查中。以下是两个典型问题及其SAT编码：

## 问题1：可达性分析

问题：状态 $\(U\)$ 是否在$\(n\)$步内从初始状态$\(Q_0\)$可达？

SAT编码：
  $$ F_{Q_0}(X_0) \wedge F_T(X_0, X_1) \wedge \cdots \wedge F_T(X_{n-1}, X_n) \wedge F_U(X_n)   $$

  - $\(F_{Q_0}(X_0)\)$：表示初始状态集合的公式。
- $\(F_T(X_i, X_{i+1})\)$：表示状态转移关系的公式。
- $\(F_U(X_n)\)$：表示目标状态集合的公式。

  若公式可满足（SAT），则 $ U $ 可达；若不可满足（UNSAT），则不可达。

## 问题2：不变性检查

问题：集合$\(I\)$是否为自动机$\(\mathcal{A}\)$的不变集（inductive invariant）？

  $$ F_{Q_0}(X) \rightarrow F_I(X) \wedge F_I(X) \wedge F_T(X, X') \rightarrow F_I(X') $$

- 若此公式为真，则$\(I\)$是不变集；否则不是。

# 3. 命题逻辑与电路表示

## 3.1 基本术语

- 变量：如 $x_1, x_2$
- 文字（Literal）：变量的正或负形式，如 $\(x_1, \neg x_2\)$
- 子句（Clause）：文字的析取，如 $\((x_1 \vee \neg x_2 \vee x_3)\)$
- 合取范式（CNF）：子句的合取，如 $\((x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_2 \vee x_1)\)$

SAT 求解器通常假设输入公式为 CNF 形式。

## 3.2 电路表示

命题逻辑公式可以通过逻辑电路表示，常见的逻辑门包括：

![circuit](https://cdn.jsdelivr.net/gh/easyformal/easyformal-site@master/content/zh/solver/image/1/circuit.png)

- AND（与）
- NAND（与非）
- OR（或）
- NOR（或非）
- NOT（非）
- XOR（异或）
- XNOR（同或）


为了提高效率，可以通过重命名子表达式来简化公式。以下是两种等价性概念：

- 重言等价（Tautologically Equivalent）：两个公式的每个满足解相同。
- 等价可满足性（Equisatisfiable）：一个公式可满足当且仅当另一个公式可满足。

示例：  


![demo1](https://cdn.jsdelivr.net/gh/easyformal/easyformal-site@master/content/zh/solver/image/1/demo1.png)

![demo2](https://cdn.jsdelivr.net/gh/easyformal/easyformal-site@master/content/zh/solver/image/1/demo2.png)


$$
(A \wedge B) \leftrightarrow E
$$

扩展为：

$$
I' \equiv (D \wedge E) \vee (\neg C \wedge E) \wedge ((A \wedge B) \leftrightarrow E)
$$

$\(I\)$和$\(I'\)$并非重言等价，但具有等价可满足性（如赋值$\(C=0, A=1, B=1, E=0\)$满足$\(I\)$）。


对于 $\((A \wedge B) \leftrightarrow E\)$，可以将公式重写为等满足的 CNF 形式，从而简化计算。

# 4. 转换为 CNF

将命题逻辑公式转换为CNF的步骤如下：

1. 将公式视为电路：识别逻辑门的层次结构。
2. 为非叶节点命名：为每个中间表达式引入新变量。
3. 添加输入/输出子句的合取：为每个非叶节点生成等价约束。
4. 取所有内容的合取：组合所有子句。

示例：

$$
E \leftrightarrow (A \wedge B)
$$

转换为：

$$
(\neg A \vee \neg B \vee E) \wedge (\neg E \vee A) \wedge (\neg E \vee B)
$$

其他示例包括：

$$
G \leftrightarrow (D \wedge E), \quad \neg F \leftrightarrow C, \quad H \leftrightarrow (F \wedge E), \quad I \leftrightarrow (H \vee G)
$$

# 5. SAT 求解算法简介

## 5.1 DPLL 算法

DPLL（Davis-Putnam-Logemann-Loveland,1962）算法 是现代 SAT 求解的核心

基本思想：对公式 $\(\alpha\)$ 执行一系列保持可满足性的转换：
- 若以空子句结束，则UNSAT。
- 若以无子句结束，则SAT。

## 5.2 DP 算法

DP（Davis-Putnam）算法 是 DPLL 的前身，使用消解（Resolution）规则简化公式，但可能导致子句数量的二次增长。

1. 单位传播（Unit Propagation）：
   - 若某子句只有一个文字$\(p\)$：
     - 从所有子句中移除$\(\neg p\)$。
     - 删除包含$\(p\)$的所有子句。
2. 纯文字（Pure Literal）：
   - 若某变量在所有子句中仅以正或负形式出现，则删除包含该文字的所有子句。
3. 消解（Resolution）：
   - 选择一个正负均出现的文字$\(p\)$：
     - $\(P\)$：包含$\(p\)$的子句集合。
     - $\(N\)$：包含$\(\neg p\)$的子句集合。
     - 对每对$\(P\)$和$\(N\)$中的子句进行消解，生成新子句（如$\((p \vee \ell_1) \wedge (\neg p \vee k_1) \rightarrow (\ell_1 \vee k_1)\)$）。
     - 注意：可能导致公式大小平方级增长。

DPLL算法在大多数问题中比 DP 算法表现出更高的效率。


# 6. SAT 建模

## 6.1 系统建模为有限状态机

我们考虑一个系统，它被定义为一个有限状态机 $\(\mathcal{A} = (Q, Q_0, T \subseteq Q \times Q)\)$，其中：
- $\(Q\) $：系统可能处于的所有状态的有限集合。
- $\(Q_0\) $：系统启动时的初始状态集合。，是 $\(Q\) $的子集。
- $\(T\)$：转移关系，定义了系统如何从一个状态转移到另一个状态，通常表示为 $\( T \subseteq Q \times Q \)$，即状态对的集合。

例如，一个简单的系统可能有三个状态 $\( Q = \{s_0, s_1, s_2\} \)$，初始状态为 $\( Q_0 = \{s_0\} \)$，转移关系为 $\( T = \{(s_0, s_1), (s_1, s_2)\} \)$。

此外，我们可能需要验证一些性质，例如：

- 不变性 $\(I\)$：一个状态集合，希望对所有可达状态都成立。
- 不安全集合 $\(U\)$：一个状态集合，想检查它们是否可以从初始状态 $\(Q_0\)$ 到达。


为了使用SAT求解器验证这些性质，我们需要将这个系统转化为命题逻辑公式。下面是具体步骤：

## 6.2 将状态编码为逻辑公式

为了后续验证（如BMC），我们需要将有限状态机的状态和行为转化为逻辑公式。这需要用到二进制变量，具体步骤如下：

- 确定变量数量：假设状态集 $\( Q \)$ 有 $\( |Q| \)$ 个状态，选择最小的整数 $\( k \)$，使得 $\( 2^k \geq |Q| \)$。这意味着我们需要 $\( k \)$ 个二进制变量来表示所有状态。
- 定义状态变量：引入一组变量 $\( X = \{x_1, x_2, \ldots, x_k\} \)$，每个变量取值为 0 或 1。每个状态 $\( q \in Q \)$ 对应一个唯一的 $\( X \)$ 赋值。
- 示例：对于 $\( Q = \{s_0, s_1, s_2\} \)$，$\( |Q| = 3 \)$，取 $\( k = 2 \)$（因为 $\( 2^2 = 4 \geq 3 \)$）。编码可以是：
  - $\( s_0 = (0,0) \)$
  - $\( s_1 = (0,1) \)$
  - $\( s_2 = (1,0) \)$

## 6.3 编码自动机的组成部分

接下来，我们将自动机的各个部分转化为命题逻辑公式，以便SAT求解器处理。

- 初始状态集 $\( Q_0 \)$：用逻辑公式 $\( F_{Q_0}(X) \)$ 表示，使其在 $\( X \)$ 对应 $\( Q_0 \)$ 中的状态时为真。
  - 示例：若 $\( Q_0 = \{s_0\} \)$，则 $\( F_{Q_0}(X) = \neg x_1 \land \neg x_2 \)$。

- 转移关系 $\( T \)$：用逻辑公式 $\( F_T(X, Y) \)$ 表示，其中 $\( X \)$ 表示当前状态，$\( Y = \{y_1, y_2, \ldots, y_k\} \)$ 表示下一状态。$\( F_T(X, Y) \)$ 在 $\( (X, Y) \)$ 对应 $\( T \)$ 中的转移时为真。
  - 示例：若 $\( T = \{(s_0, s_1), (s_1, s_2)\} \)$，则：
    - $\( F_T(X, Y) = [(\neg x_1 \land \neg x_2) \land (\neg y_1 \land y_2)] \lor [(\neg x_1 \land x_2) \land (y_1 \land \neg y_2)] \)$。

- 目标状态集 $\( U \)$（如不安全状态）：用逻辑公式 $\( F_U(X) \)$ 表示，使其在 $\( X \)$ 对应 $\( U \)$ 中的状态时为真。
  - 示例：若 $\( U = \{s_2\} \)$，则 $\( F_U(X) = x_1 \land \neg x_2 \)$。

通过这种编码，有限状态机的所有行为都被转化为逻辑公式，为后续验证奠定了基础。


## 6.4 使用SAT求解器验证性质

通过上述编码，我们可以将验证问题转化为SAT问题。以下是两个常见应用：

(1) 检查可达性
- 问题：不安全状态 $\(U\)$ 是否可以从 $\(Q_0\)$ 在 $\(n\)$ 步内到达？
- 构建公式：
$$
  F_{Q_0}(X_0) \land F_T(X_0, X_1) \land F_T(X_1, X_2) \land \cdots \land F_T(X_{n-1}, X_n) \land F_U(X_n)
$$
  - $\(X_0, X_1, \ldots, X_n\)$ 是状态变量的 $\(n+1\)$ 个副本，表示一个状态序列。
  - 如果这个公式可满足（SAT），则存在从 $\(Q_0\)$ 到 $\(U\)$ 的 $\(n\)$ 步路径。
  - 如果不可满足（UNSAT），则不存在这样的路径。

(2) 检查不变性
- 问题：不变性 $\(I\)$ 是否对所有可达状态成立？
- 方法类似，但需要检查所有可达状态是否都在 $\(I\)$ 中，通常通过否定 $\(I\)$ 并检查其不可达性来实现。

# 7. BMC

## 7. 1 什么是BMC？

Bounded Model Checking (BMC) 是一种用于验证系统性质的方法，特别适用于检查系统在有限步数内是否满足某些性质。

BMC通常解决可达性问题：从初始状态 $\( Q_0 \)$ 出发，经过 $\( n \)$ 步转移，是否能到达目标状态 $\( U \)$。

BMC 的核心思想是将这个问题转化为一个命题逻辑的可满足性问题（SAT问题），然后利用高效的 SAT 求解器来判断结果。

## 7. 2 BMC的工作原理

BMC的核心是将 $\( n \)$ 步路径编码为逻辑公式，具体步骤如下：

- 路径定义：一个长度为 $\( n \)$ 的路径包含 $\( n+1 \)$ 个状态（$\( X_0, X_1, \ldots, X_n \)$），以及 $\( n \)$ 次转移（$\( X_0 \rightarrow X_1 \rightarrow \cdots \rightarrow X_n \)$）。
- 逻辑公式：BMC构造以下公式：
$$
  F_{Q_0}(X_0) \wedge F_T(X_0, X_1) \wedge F_T(X_1, X_2) \wedge \cdots \wedge F_T(X_{n-1}, X_n) \wedge F_U(X_n)
$$
  - $\( F_{Q_0}(X_0) \)$：路径从初始状态开始。
  - $\( F_T(X_i, X_{i+1}) \)$：每一步转移满足 $\( T \)$。
  - $\( F_U(X_n) \)$：路径终点在 $\( U \)$ 中。

- SAT求解：
  - 如果公式可满足（SAT），说明存在一条 $\( n \)$ 步路径从 $\( Q_0 \)$ 到 $\( U \)$。
  - 如果公式不可满足（UNSAT），说明 $\( n \)$ 步内无法到达 $\( U \)$。

## 7. 3 示例应用

继续使用上一章的例子：
- $\( Q = \{s_0, s_1, s_2\} \)$
- $\( Q_0 = \{s_0\} \)$
- $\( T = \{(s_0, s_1), (s_1, s_2)\} \)$
- $\( U = \{s_2\} \)$

检查 $\( n = 2 \)$ 步内是否能到达 $\( U \)$：
- 公式：
$$
  F_{Q_0}(X_0) \wedge F_T(X_0, X_1) \wedge F_T(X_1, X_2) \wedge F_U(X_2)
$$
- 代入编码：
  - $\( F_{Q_0}(X_0) = \neg x_{01} \land \neg x_{02} \)$
  - $\( F_T(X_0, X_1) = [(\neg x_{01} \land \neg x_{02}) \land (\neg x_{11} \land x_{12})] \lor [(\neg x_{01} \land x_{02}) \land (x_{11} \land \neg x_{12})] \)$
  - $\( F_T(X_1, X_2) = [(\neg x_{11} \land \neg x_{12}) \land (\neg x_{21} \land x_{22})] \lor [(\neg x_{11} \land x_{12}) \land (x_{21} \land \neg x_{22})] \)$
  - $\( F_U(X_2) = x_{21} \land \neg x_{22} \)$

SAT求解器可能找到一个解：
- $\( X_0 = (0,0) \)$（$\( s_0 \)$）
- $\( X_1 = (0,1) \)$（$\( s_1 \)$）
- $\( X_2 = (1,0) \)$（$\( s_2 \)$）

这表明存在路径 $\( s_0 \rightarrow s_1 \rightarrow s_2 \)$，即 $\( s_2 \)$ 在2步内可达。

## 7. 4 BMC的优缺点

- 优点：
  - 利用高效SAT求解器，适合处理大规模系统。
  - 擅长发现错误路径。
- 缺点：
  - 仅限于有限步数，无法证明无限步的性质。
  - $ \( n \) $ 较大时，公式复杂度增加，可能影响求解效率。


# 8. SMT 求解器

## 8.1 架构
  
SMT 求解器将问题分解为 SAT 问题和特定理论的决策过程：

- SAT 核心：处理命题逻辑结构。
- 理论求解器：处理特定理论的约束（如算术、数组等）。

## 8.2 支持的理论

SMT 支持多种理论，包括：
- 未解释函数（UF）：处理函数相等性。
- 算术：包括差分逻辑、线性算术、非线性算术。
- 数组：处理读写操作。
- 位向量：处理位级操作。

## 8.3 决策过程示例

以 UF 理论为例，判断公式 $\(x_1 = x_2 \wedge x_2 = x_3 \wedge x_4 = x_5 \wedge x_5 \neq x_1 \wedge F(x_1) \neq F(x_3)\)$ 的可满足性，使用 congruence closure 算法逐步合并等价类，最终得出不可满足。

# 9. SMT 求解方法

## 9.1 急切方法（Eager Approach）

将 SMT 问题直接转换为等价的 SAT 问题。

## 9.2 惰性方法（Lazy Approach）

将 SMT 问题抽象为 SAT 问题，通过与理论求解器交互逐步精炼。

示例：  
对于 $\(\Phi := g(a) = c \wedge f(g(a)) + f(c) \vee g(a) = d \wedge c + d\)$，通过 SAT 和 UF 求解器的多次交互，最终判定不可满足。


# 附录 - 术语

- SAT：Satisfiability，可满足性
- SMT：Satisfiability Modulo Theories，模理论可满足性
- BMC：Bounded model checking，有界模型检查